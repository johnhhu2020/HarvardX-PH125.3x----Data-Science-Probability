---
title: 'HarvardX PH125.3x -- Data Science: Probability'
author: "John HHU"
date: '2022-05-30'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.








## Course  /  Section 1: Discrete Probability  /  Section 1 Overview


# Section 1 Overview


Section 1 introduces you to Discrete Probability. Section 1 is divided into three parts:

[][*        Introduction to Discrete Probability*]
            *A discrete probability distribution counts occurrences that have countable or finite outcomes.*
[][*        Combinations and Permutations*]
            *When the order doesn't matter, it is a Combination. When the order does matter it is a Permutation*]
[][*        Addition Rule and Monty Hall*]
            *https://www.varsitytutors.com/hotmath/hotmath_help/topics/addition-rule-of-probability*
            *https://www.mathgoodies.com/lessons/vol6/addition_rules*
            *Google Monty Hall problem*

After completing Section 1, you will be able to:

        apply basic probability theory to categorical data.
        perform a Monte Carlo simulation to approximate the results of repeating an experiment over and over, including simulating the outcomes in the Monty Hall problem.
        distinguish between: sampling with and without replacement, events that are and are not independent, and combinations and permutations.
        apply the multiplication and addition rules, as appropriate, to calculate the probably of multiple events occurring.
        use sapply() instead of a for loop to perform element-wise operations on a function.

There are 3 assignments that use the DataCamp platform for you to practice your coding skills. There are also some quick probability calculations for you to perform directly on the edX platform as well, and there is a longer set of problems at the end of section 1.

This section corresponds to the following section of the course textbook.
https://rafalab.github.io/dsbook/probability.html#discrete-probability

We encourage you to use R to interactively test out your answers and further your learning.







## Course  /  Section 1: Discrete Probability  /  1.1 Introduction to Discrete Probability


# Discrete Probability


We start by covering some basic principles related to categorical data.  This subset of probability is referred to as [][*discrete probability*].  ***It will help us understand the probability theory we will later introduce for numeric and continuous data, which is more common in data science applications***.  Discrete probability is more useful in card games and we use these as examples.  The word probability is used in everyday language.  For example, Google's auto complete of, what are the chances of, gives us getting pregnant, having twins, and rain tomorrow.  Answering questions about probability is often hard, if not impossible.  Here, we discuss a mathematical definition of probability that does permit us to give precise answers to certain questions.  

For example, if I have two red beads and three blue beads inside an urn and I pick one at random, what is the probability of picking a red one?  Our intuition tells us that the answer is 2/5, or 40%.  A precise definition can be given by noting that ***there are five possible outcomes of which two satisfy the condition necessary for the event "pick a red bead."***  Because each of the five outcomes has the same chance of occurring, we conclude that the probability is 0.4 for red and 0.6 for blue.  

[][*A more tangible way to think about the probability of an event is as a proportion of times the event occurs when we repeat the experiment over and over independently and under the same conditions*].  Before we continue, let's introduce some notation.  We use the notation probability of A to denote the probability of an event A happening.  We use the very general term event to refer to things that can happen when something happens by chance.  

For example, in our previous example, the event was picking a red bead.  In a political poll, in which we call 100 likely voters
at random, an example of an event is calling 48 Democrats and 52 Republicans.  [][***In data science applications, we will often deal with continuous variables*].  In these cases, events will often be things like, ***is this person taller than 6 feet?***  In this case, we write events in a more mathematical form.  For example, x greater than 6.  We'll see more of these examples later.  Here, we focus on categorical data and discrete probability.


[][Textbook link]

This video corresponds to the textbook section on discrete probability External link.
https://rafalab.github.io/dsbook/probability.html#discrete-probability


[][Key points]

    The probability of an event is the proportion of times the event occurs when we repeat the experiment independently under the same conditions.
    Pr(A) = probability of event A
    An event is defined as an outcome that can occur when when something happens by chance.
    We can determine probabilities related to discrete variables (picking a red bead, choosing 48 Democrats and 52 Republicans from 100 likely voters) and continuous variables (height over 6 feet).



![](C:/Users/JJ/Pictures/discrete probability.png)

![](C:/Users/JJ/Pictures/googles auto complete of what are the chance of ....png)

![](C:/Users/JJ/Pictures/having rains tomorrow.png)

![](C:/Users/JJ/Pictures/picking beads rnadomly from a urn.png)

![](C:/Users/JJ/Pictures/a precise definition giving that there are 5 possible outcomes of which 2 satisfy the condition necessary.png)

![](C:/Users/JJ/Pictures/A more tangible way to think about the probability of an event is as a condition of times the events occurs.png)

![](C:/Users/JJ/Pictures/paobability of a notation.png)

![](C:/Users/JJ/Pictures/term event to refering things can happen when something happens by chance.png)

![in data science we will often deal with continuous variables.png](C:/Users/JJ/Pictures/in data science we will often deal with continuous variables.png)

![](C:/Users/JJ/Pictures/events sample in data science dealing with continuous variable.png)

![](C:/Users/JJ/Pictures/then we write it in a more mathematical form.png)









# Monte Carlo Simulations


Computers provide a way to actually perform the simple random experiments, such as the one we did before.  Pick a bead at random from a bag or an urn with 3 blue beads and 2 red ones.  [][*Random number generators*] permit us to mimic the process of picking at random.  An example in R is the sample() function.  We demonstrate its use showing you some code.  First, use the rep() function to generate the urn.  We create an urn with 2 red and 3 blues.  You can see when we type beads we see this.  Now, we can use a sample() function to pick one at random.  If we type sample beads comma 1, in this case, we get a blue.  This line of code produces one random outcome.  Now, we want to repeat this experiment over and over.  

However, it is, of course, impossible to repeat forever.  Instead, we repeat the experiment a large enough number of times to make the results practically equivalent to doing it over and over forever.  [][*This is an example of a Monte Carlo simulation*].  Note that much of what mathematical and theoretical statisticians study--something we do not cover in this course--relates to providing rigorous definitions of *practically equivalent*, as well as studying how close a large number of experiment gets us to what happens in the limit, the limit meaning if we did it forever.  [][********Later in this module, we provide a practical approach to deciding what is large enough********].  

To perform our first Monte Carlo simulation, we use the replicate() function.  This permits us to repeat the same task any number of times we want.  Here, we repeat the random event 10,000 times.  We set B to be 10,000, then we use the replicate() function to sample from the beads 10,000 times.  We can now see if, in fact, our definition is in agreement with this Monte Carlo simulation approximation.  *We can use table(), for example, to see the distribution.  And then we can use prop.table() to give us the proportions*.  And we see that, in fact, the Monte Carlo simulation gives a very good approximation with 0.5962 for blue and 0.4038 for red.  We didn't get exactly 0.6 and exactly 0.4, but statistical theory tells us that, if we make B large enough, we can get as close as we want to those numbers.  We just covered a simple and not very useful example of Monte Carlo simulations.  

But we will use Monte Carlo simulation to estimate probabilities in cases in which it is harder to compute the exact ones.  Before we go into more complex examples, we still use simple ones to demonstrate the computing tools available in R.  Let's start by noting that we don't actually have to use replicate() in this particular example.  This is because the function sample() has an argument that permits us to pick more than one element from the urn.  However, by default, this selection occurs without replacement.  After a bead is selected, it is not put back in the urn.  Note what happens when we ask to randomly select 5 beads.  Let's do it over and over again.  Let's do it three times.  This results in a rearrangement that always has three blue and two red beads.  If we asked for six beads, then we get an error.  It tells us you don't have enough beads in here to get six.  

This is because it's doing it without replacement.  However, this function, the sample function, can be used directly--again, without the replicate--to repeat the same experiment of picking 1 out of 5 beads over and over under the same conditions.  To do this, we sample with replacement.  After we pick the bead we put it back in the urn.  We can tell sample to do this by changing the *replace = * argument which defaults to false to true.  We do it like this.  And when we do this, we see that we get very similar answers to what  we got using the replicate function.  


[][Textbook link]

This video corresponds to the textbook section on Monte Carlo simulations.
https://rafalab.github.io/dsbook/probability.html#monte-carlo-simulations


[][Key points]

    Monte Carlo simulations model the probability of different outcomes by repeating a random process a large enough number of times that the results are similar to what would be observed if the process were repeated forever.

    The sample() function draws random outcomes from a set of options.
    The replicate() function repeats lines of code a set number of times. It is used with sample() and similar functions to run Monte Carlo simulations.

Video code

Note that your exact outcome values from the Monte Carlo simulation will differ because the sampling is random.

beads <- rep(c("red", "blue"), times = c(2,3))    # create an urn with 2 red, 3 blue
beads    # view beads object
sample(beads, 1)    # sample 1 bead at random

B <- 10000    # number of times to draw 1 bead
events <- replicate(B, sample(beads, 1))    # draw 1 bead, B times
tab <- table(events)    # make a table of outcome counts
tab    # view count table
prop.table(tab)    # view table of outcome proportions



```{r}
beads = rep(c("red", "blue"), times = c(2, 3) )


sample(beads, 100, replace = T)


tab = table(sample(beads, 10000, replace = T))
prop.table(tab)
```



![](C:/Users/JJ/Pictures/computer provides us the random number enerators.png)

![](C:/Users/JJ/Pictures/sample function in r helps us apply a random experiment.png)

![](C:/Users/JJ/Pictures/use rep function to create a urn includes 2 red and 3 blue.png)


![](C:/Users/JJ/Pictures/and now we can produce 1 random outcome.png)

![](C:/Users/JJ/Pictures/monte carlo simulation.png)

![](C:/Users/JJ/Pictures/replicate function premits us to repeat same task any number of time we want.png)

![](C:/Users/JJ/Pictures/now we repeat the random event 10 thousand times and check the outcome.png)

![](C:/Users/JJ/Pictures/we can use table function to see the distribution.png)

![](C:/Users/JJ/Pictures/and use the prop.table function to see the proportions.png)

![](C:/Users/JJ/Pictures/default sample function repeat offers us without replacement experiment.png)

![](C:/Users/JJ/Pictures/sample one by one and we get this, without replacement.png)

![](C:/Users/JJ/Pictures/and now we don't have enough beads in urn.png)

![](C:/Users/JJ/Pictures/now check what happens on your own what happends if we change default replace arg from FALSE to T.png)









# Setting the Random Seed


The set.seed() function

Before we continue, we will briefly explain the following important line of code:

set.seed(1986) 

Throughout this book, we use random number generators. This implies that many of the results presented can actually change by chance, which then suggests that a frozen version of the book may show a different result than what you obtain when you try to code as shown in the book. This is actually fine since the results are random and change from time to time. However, if you want to to ensure that results are exactly the same every time you run them, you can set R’s random number generation seed to a specific number. Above we set it to 1986. We want to avoid using the same seed every time. A popular way to pick the seed is the year - month - day. For example, we picked 1986 on December 20, 2018:  2018 − 12 − 20 = 1986.

You can learn more about setting the seed by looking at the documentation:

?set.seed

In the exercises, we may ask you to set the seed to assure that the results you obtain are exactly what we expect them to be.
Important note on seeds in R 3.5 versus R 3.6 and later

When R updated to version 3.6 in early 2019, the default method for setting the seed changed. This means that exercises, videos, textbook excerpts and other code you encounter online may yield a different result based on your version of R.

[][*If you are running R 3.6 or later, you can revert to the original seed setting behavior by adding the argument sample.kind="Rounding". For example:*]

set.seed(1)
set.seed(1, sample.kind="Rounding")    # will make R 3.6 generate a seed as in R 3.5

Using the sample.kind="Rounding" argument will generate a message:

**non-uniform 'Rounding' sampler used**

This is not a warning or a cause for alarm - it is a confirmation that R is using the alternate seed generation method, and you should expect to receive this message in your console.

If you use R 3.6 or later, you should always use the second form of set.seed() in this course series (outside of DataCamp assignments). Failure to do so may result in an otherwise correct answer being rejected by the grader. In most cases where a seed is required, you will be reminded of this fact.


```{r}
set.seed(1986, sample.kind="Rounding")
```







# Using the mean Function for Probability


An important application of the mean() function

[][*In R, applying the mean() function to a logical vector returns the proportion of elements that are TRUE*]. It is very common to use the mean() function in this way to calculate probabilities and we will do so throughout the course.

Suppose you have the vector beads from a previous video:

beads <- rep(c("red", "blue"), times = c(2,3))
beads
[1] "red" "red" "blue" "blue" "blue"

To find the probability of drawing a blue bead at random, you can run:

mean(beads == "blue")
[1] 0.6

This code is broken down into steps inside R. First, R evaluates the logical statement beads == "blue", which generates the vector:

FALSE FALSE TRUE TRUE TRUE

When the mean function is applied, R coerces the logical values to numeric values, changing TRUE to 1 and FALSE to 0:

0 0 1 1 1

The mean of the zeros and ones thus gives the proportion of TRUE values. As we have learned and will continue to see, probabilities are directly related to the proportion of events that satisfy a requirement.






# Probability Distributions


[][***Defining a distribution for categorical outcomes is relatively straight forward***].  We simply assign a probability to each category.  In cases that can be thought of as beads in an urn, for each bead type, the proportion defines the distribution.  Another example comes from polling.  If you're are randomly calling likely voters from a population that has 44% Democrat, 44% Republican, 10% undecided, and 2% green, these proportions define the probability for each group.  For this example, the probability distribution is simply these four proportions.  

Again, categorical data makes it easy to define probability distributions.  However, later in applications that are more common in data science,  we will learn about probability distributions for continuous variables.  In this case, it'll get a little bit more complex.  But for now, we're going to stick to discrete probabilities before we move on.  


[][Textbook link]

This video corresponds to the textbook section on probability distributions.
https://rafalab.github.io/dsbook/probability.html#discrete-probability-distributions



[][Key points]

    The probability distribution for a variable describes the probability of observing each possible outcome.
    For discrete categorical variables, the probability distribution is defined by the proportions for each group.



![for each bead type, the proportion defines the distribution](C:/Users/JJ/Pictures/beads in a urn for each bead type.png)

![categorical data makes it easy to define probability distribution](C:/Users/JJ/Pictures/this proportion defines the probability for each group.png)

(  *A discrete probability distribution counts occurrences that have countable or finite outcomes. This is in contrast to a continuous distribution, where outcomes can fall anywhere on a continuum. Common examples of discrete distribution include the binomial, Poisson, and Bernoulli distributions.*  )









# Independence


We say that two events are independent if the outcome of one does not affect the other.  This classic example are coin tosses.  Every time we toss a fair coin, the probability of seeing heads is one half, regardless of what previous tosses have revealed.  The same is true when we pick beads from an urn, with replacement.  In the example we saw earlier, the probability of red was 0.40, regardless of previous draws.  Many examples of events that are not independent come from card games.  When we deal the first card, the probability of getting, say a King, is 1 in 13.  This is because there are 13 possibilities.  You can get an ace, a two, a three, a four, et cetera, 10, Jack, Queen, or King.  Now, if we deal a King for the first card, and I don't replace it, then the probability of getting a King in the second card is less, because there are only three Kings left.  The probability is 3 out of not 52, because we already dealt one card, but out of 51.  These events are, therefore, not independent.  

[][*The first outcome affects the second*].  To see an extreme case of non-independent events, consider an example of drawing five beads at random, without replacement, from an urn.  Three are blue, two are red.  I'm going to generate data like this using the sample() function and assign it to x.  You can't see the outcomes.  Now, if I ask you to guess the color of the first bead, what do you guess?  Since there's more blue beads, there's actually a 0.6 chance of seeing blue.  That's probably what you guess.  **But now I'm going to show you the outcomes of the other four**.  The second, third, fourth, and fifth outcomes you can see here.  You can see that the three blue beads have already come out.  This affects the probability of the first.  They are not independent.  So would you still guess blue?  Of course not.  Now you know that the probability of red is 1.  

These events are not independent.  The probabilities change once you see the other outcomes.  When events are not independent, conditional probabilities are useful and necessary to make correct calculations.  We already saw an example of a conditional probability.  We computed the probability that a second dealt card is a King, given that the first was a King.  In probability, we use the following notation.  We use this dash like this as a shorthand for given that or conditional on, these are synonyms.  Note that, [][*when two events, say A and B, are independent, we have the following equation.  The probability of A given B is equal to the probability of A*].  It doesn't matter what B is.  The probability A is unchanged.  This is the mathematical way of saying it.  And in fact, this can be considered the mathematical definition of independence.  

All right now, if we want to know the probability of two events, say A and B, occurring, we can use the multiplication rule.  **So the probability of A and B is equal to the probability of A multiplied by the probability of B, given that A already happened**.  Let's use blackjack as an example.  In blackjack, you get assigned to random cards, without replacement.  Then you can ask for more.  The goal is to get closer to 21 than the dealer, without going over.  Face cards are worth 10 points, so is the 10 card, that's worth 10 points too.  And aces are worth either 11 or 1.  So if you get an ace and a face card, you win automatically.  

So, in blackjack, to calculate the chances of getting 21 in the following way, first we get an ace.  And then we get a face card or a 10.  We compute the probability of the first being an ace.  And then multiply by the probability of a face card or a 10, given that the first card was an ace.  The calculation is 1 over 13 chance of getting an ace, times chance of getting a card with value 10, given that we already saw an ace, which is 16 out of 51.  We've already taken one card out.  This is approximately 2%.  The multiplicative rule also applies to more than two events.  We can use induction to expand for more than two.  So the probability of A and B and C is equal to the probability of A times our probability of B, given that A happen, times the probability of C, that A and B happen.  

When we have independent events, the multiplication rule becomes simpler.  We simply multiply of three probabilities.  But we have to be very careful when we use the multiplicative rule in practice.  We're assuming independence.  And this can result in very different and incorrect probability calculations when we don't actually have independence.  This can have dire consequences.  For example, in a trial, if an expert doesn't really know the multiplication rule and how to use it.  So let's use an example.  This is loosely based on something that actually happened.  Imagine a court case in which the suspect was described to have a mustache and a beard.  And the prosecution brings in an expert to argue that because 1 in 10 men have beards, and 1 in 5 men has mustaches, using the multiplication rule, this means that only 2% of men have both beards and mustaches, 1/10 times 1/5.  2% is a pretty unlikely event.  However, to multiply like this, we need to assume independence.  And in this case, it's clearly not true.  The conditional probability of a man having a mustache, conditional on them having a beard, is quite high.  It's about 95%.  So the correct calculation actually gives us a much higher probability.  It's 9%, so there's definitely reasonable doubt.  


[][Textbook link]

This video corresponds to the textbook section on independence, conditional probability and the multiplication rule.
https://rafalab.github.io/dsbook/probability.html#independence



[][Key points]

    Conditional probabilities compute the probability that an event occurs given information about dependent events. For example, the probability of drawing a second king given that the first draw is a king is:
    
[][       Pr(Card 2 is kind | Card 1 is king) = 3/51]
    
[][       If two events A and B are independent, Pr(A|B) = Pr(A)]
    .
    To determine the probability of multiple events occurring, we use the multiplication rule.

Equations


The **multiplication rule for independent events** is:

[][       Pr(A and B and C) = Pr(A) x Pr(B) x Pr(c)]

The multiplication rule for dependent events considers the conditional probability of both events occurring:

[][       Pr(A and B) = Pr(A) x Pr(B|A)]

We can expand the multiplication rule for dependent events to more than 2 events:

[][       Pr(A and B and C) = Pr(A) x Pr(B|A) x Pr(C| A and B)]



![](C:/Users/JJ/Pictures/definition of independent.png)

![](C:/Users/JJ/Pictures/toss coin is a example of independent.png)

![with replacement](C:/Users/JJ/Pictures/pick bead from urn is also a independent.png)

![The first outcome affects the second](C:/Users/JJ/Pictures/not independent event example are card games.png)

![not independent events are without replacement card games.png](C:/Users/JJ/Pictures/not independent events are without replacement card games.png)

![compute the probability that the second dealt card is king, given that the first was king](C:/Users/JJ/Pictures/when events are not independent, conditional probabilities are useful and necessary.png)

![](C:/Users/JJ/Pictures/in probability we use following notation to represent conditional probability.png)

![](C:/Users/JJ/Pictures/notice when 2 events are independent, we have following equation.png)

![](C:/Users/JJ/Pictures/applies the multiplication rule to calculate the probability of 2 events occurring.png)

![so the probability of a and b is equal to the probability of a multiplied by the probability of b given that a already happened.png](C:/Users/JJ/Pictures/so the probability of a and b is equal to the probability of a multiplied by the probability of b given that a already happened.png)

![](C:/Users/JJ/Pictures/blackjack game winning rate is you first get ace card then get 10 or face card.png)

![](C:/Users/JJ/Pictures/the multiplicative rule also applies to more then two events.png)

![](C:/Users/JJ/Pictures/for independent events, the multiplication rule becomes simpler.png)

![](C:/Users/JJ/Pictures/how to know if the events are independent or not.png)

![](C:/Users/JJ/Pictures/having mustache and beard.png)

![](C:/Users/JJ/Pictures/1 in 10 men has beard and 1 in 5 men has mustache.png)

![assume independence, not true at all.png](C:/Users/JJ/Pictures/assume independence, not true at all.png)

![](C:/Users/JJ/Pictures/The conditional probability of a man having a mustache, conditional on them.png)



# Question from last video about beard and mustaches?

question posted 2 days ago by john_hhu2020

Sorry I don't get it, I thought it was 95%, since the instructor mentioned below in the video:

    Pr(mustache | beard) = 0.95

I don't know how does this comes out (this answer or the answer on the book, since it mentioned this: "1/10×95/100=0.095" under this hypothesis: "Say the conditional probability of a man having a mustache conditional on him having a beard is .95"). Say if we applies the multiplicative rule here:

    Pr(m and B) = Pr(m) x Pr(b|m)

and since we have 10 sample, Pr(m) = 1/5, Pr(b) = 1/10, then what is the probability of Pr(b|m)? And whats the difference between Pr(b and m) and Pr(b|m), as I cant image the situation of these.

The question is: in this case, what is the difference between Pr(b and m) and Pr(b|m) ???
This post is visible to everyone.
0 responses

    john_hhu2020

    less than a minute ago

# =================================================================================================================================
I see, so the conditionally probability means a situation change: both Numerator and Denominator was changed due to the first event have happened.
Thus the Pr(mustache | beard) must be given, and only then we can calculate the Pr(mustache and beard), and this Pr(mustache and beard) means the probability of guy met both conditions in the first condition - the Numerator and Denominator haven't changed. Anyone willing to help please write something, especially the instructor









# Assessment: Introduction to Discrete Probability



Assessment due Jun 15, 2022 10:43 AWST


## Probability of cyan
1/1 point (graded)

One ball will be drawn at random from a box containing: 3 cyan balls, 5 magenta balls, and 7 yellow balls.
What is the probability that the ball will be cyan?
correct

Loading
You have used 1 of 5 attempts Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Correct (1/1 point)


## Probability of not cyan
1/1 point (graded)

One ball will be drawn at random from a box containing: 3 cyan balls, 5 magenta balls, and 7 yellow balls.
What is the probability that the ball will not be cyan?
correct

Loading
You have used 1 of 5 attempts Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Correct (1/1 point)


## Sampling without replacement
1/1 point (graded)

Instead of taking just one draw, consider taking two draws. You take the second draw without returning the first draw to the box. We call this sampling without replacement.
What is the probability that the first draw is cyan and that the second draw is not cyan?

Provide at least 3 significant digits.
correct

Loading
You have used 1 of 5 attempts Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Correct (1/1 point)


## Sampling with replacement
1/1 point (graded)

Now repeat the experiment, but this time, after taking the first draw and recording the color, return it back to the box and shake the box. We call this sampling with replacement.
What is the probability that the first draw is cyan and that the second draw is not cyan?
correct

Loading
You have used 1 of 5 attempts Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.
Correct (1/1 point)

Have a question about these assessments? Search the discussion forum BEFORE posting below.

Some reminders:

    Please be specific in the title and body of your post regarding which question you're asking about to facilitate answering your question.
    Posting snippets of code is okay, but posting full code solutions is not.
    If you do post snippets of code, please format it as code for readability. If you're not sure how to do this, there are instructions in a pinned post in the discussion forum.

Discussion: Assessment: Introduction to discrete probability'
Topic: Section 1 / Assessment: Introduction to discrete probability






a box containing: 3 cyan balls, 5 magenta balls, and 7 yellow balls. 

# What is the probability that the first draw is cyan and that the second draw is not cyan?

Pr(A) Cyan

Pr(B) not Cyan


Pr(A and B) = Pr(A) x Pr(B|A)
            = 3/15 x 12/14
            = 1/5 x 6/7
            = 6/35


3/15 x 12/15
1/5 x 4/5
4/25









# Introduction to DataCamp


DataCamp

You are about the take the first DataCamp assessment. In this course we will be using the DataCamp platform for some assessments. DataCamp provides an R console and and a script editor right here on your browser. Here we give a brief DataCamp tutorial. If you are already familiar with DataCamp you can skip this section and proceed to the next section

To start a DataCamp assessment, you will click on the button that says [][Click here to start the assessment], which looks like this: *Click here to start the assessment* picture of start the assessment button. You will see a button like this one in the next section: [][*Assessment: Introduction to Discrete Probability*].

The DataCamp interface has four panels. They are:

    The Information Panel: General information about the assessment.
    The Instructions Panel: Exercise instructions. The multiple choice questions appear here when applicable.
    The Editor: Here is where you type and edit your answers in the form of an R script. Example code also appears here. The editor also includes reminders of the instructions.  Note that # denotes comments. These are not run as code, instead, they tell others what your code is about! 
    R console: This is where R commands get executed. You can send commands from the editor to the console but you can also type in commands directly to test out code.

Here is a screenshot of what DataCamp looks like:

Image of DataCamp Platform

![](C:/Users/JJ/Pictures/datacamp interface.png)

There are two ways to send commands from the editor to the console:

1) If you hit the  Submit Answer button, the entire code in the editor gets executed and your answer is evaluated. Remember, after you click Submit Answer in an assessment, your code will be evaluated. If you do not take the hint, you get unlimited tries.

2) If your cursor is on the editor and you hit command-return on a Mac or control-return on Windows, that line gets executed in the console. You do not submit an answer when you do this. This is a good way to test your script before you submit.

Tip: DataCamp suggests useful keyboard shortcuts after most exercises.

![](C:/Users/JJ/Pictures/datacamp exercise pannel.png)

After submit answer on the platform










# DataCamp Assessment: Introduction to Discrete Probability



Assessment due Jun 15, 2022 10:43 AWST

This assessment covers the basics of discrete probability. There are two parts to this assessment: the first part is a set of questions on the edX platform, and the second part is a set of coding questions on the DataCamp platform.

In this assessment, you will learn about the fundamentals of discrete probability through looking at examples of sampling from an urn with and without replacement.

By clicking OK, you agree to DataCamp's privacy policy: https://www.datacamp.com/privacy-policy. Note that you might need to disable your pop-up blocker, or allow "www.datacamp.com" in your pop-up blocker allowed list. When you have completed the exercises, return to edX to continue your learning.

**Assessment: Introduction to discrete probability (External resource) (4.5 points possible)**
By clicking OK, you agree to DataCamp's privacy policy: https://www.datacamp.com/privacy-policy.
https://courses.edx.org/courses/course-v1:HarvardX+PH125.3x+1T2022/xblock/block-v1:HarvardX+PH125.3x+1T2022+type@lti_consumer+block@f8d6dedea9284f2bb67b368dc05d0a38/handler/lti_launch_handler
You must be logged in to DataCamp to view your lab scores. To log in, simply click on one of the launch links above (even if you're not planning to work on a lab right now, but just want to view your scores). Then, refresh this page to view your scores.

 

Have a question about this assessment? Search the discussion forum to see if someone else has asked or answered your question BEFORE posting below.

Some reminders:

    Please be specific in the title and body of your post regarding which question you're asking about to facilitate answering your question.
    Posting snippets of code is okay, but posting full code solutions is not.
    If you do post snippets of code, please format it as code for readability. If you're not sure how to do this, there are instructions in a pinned post in the general discussion forum.

Discussion: DataCamp Assessment: Introduction to discrete probability
Topic: Section 1 / DataCamp Assessment: Introduction to discrete probability



## Exercise 1. Probability of cyan - generalized

In the edX exercises for this section, we calculated some probabilities by hand. Now we'll calculate those probabilities using R.

One ball will be drawn at random from a box containing: 3 cyan balls, 5 magenta balls, and 7 yellow balls.

What is the probability that the ball will be cyan?
Instructions
70 XP

    Define a variable p as the probability of choosing a cyan ball from the box.
    Print the value of p.

Hint

    Calculate the proportion of balls in the box that are cyan and assign that value to the variable p.
    To print the contents of a variable, write the variable name in a new line of code.

```{r}
cyan <- 3
magenta <- 5
yellow <- 7

# Assign a variable `p` as the probability of choosing a cyan ball from the box
#p <- rep(c("cyan", "magenta", "yellow"), times=c(3, 5, 7))
p <- cyan/(cyan + magenta + yellow)

# Print the variable `p` to the console
p
```



## Exercise 2. Probability of not cyan - generalized

We defined the variable p as the probability of choosing a cyan ball from a box containing: 3 cyan balls, 5 magenta balls, and 7 yellow balls.

What is the probability that the ball you draw from the box will NOT be cyan?
Instructions
100 XP

    Using the probability of choosing a cyan ball, p, calculate the probability of choosing any other ball.

```{r}
# `p` is defined as the probability of choosing a cyan ball from a box containing: 3 cyan balls, 5 magenta balls, and 7 yellow balls.
# Using variable `p`, calculate the probability of choosing any ball that is not cyan from the box

1-p
```


## Exercise 3. Sampling without replacement - generalized

Instead of taking just one draw, consider taking two draws. You take the second draw without returning the first draw to the box. We call this sampling without replacement.

What is the probability that the first draw is cyan and that the second draw is not cyan?
Instructions
100 XP

    Calculate the conditional probability p_2 of choosing a ball that is not cyan after one cyan ball has been removed from the box.
    Calculate the joint probability of both choosing a cyan ball on the first draw and a ball that is not cyan on the second draw using p_1 and p_2.

```{r}
cyan <- 3
magenta <- 5
yellow <- 7

# The variable `p_1` is the probability of choosing a cyan ball from the box on the first draw.
p_1 <- cyan / (cyan + magenta + yellow)

# Assign a variable `p_2` as the probability of not choosing a cyan ball on the second draw without replacement.

# Calculate the probability that the first draw is cyan and the second draw is not cyan using `p_1` and `p_2`.



# The variable `p_1` is the probability of choosing a cyan ball from the box on the first draw.
p_1 <- cyan / (cyan + magenta + yellow)
p_1

# Assign a variable `p_2` as the probability of not choosing a cyan ball on the second draw without replacement.
p_2 <- (magenta + yellow)/(cyan + magenta + yellow - 1)
p_2

# Calculate the probability that the first draw is cyan and the second draw is not cyan using `p_1` and `p_2`.
p_1 * p_2
```


## Exercise 4. Sampling with replacement - generalized

Now repeat the experiment, but this time, after taking the first draw and recording the color, return it back to the box and shake the box. We call this sampling with replacement.

What is the probability that the first draw is cyan and that the second draw is not cyan?
Instructions
100 XP

    Calculate the probability p_2 of choosing a ball that is not cyan on the second draw, with replacement.
    Next, use p_1 and p_2 to calculate the probability of choosing a cyan ball on the first draw and a ball that is not cyan on the second draw (after replacing the first ball).

```{r}
cyan <- 3
magenta <- 5
yellow <- 7

# The variable 'p_1' is the probability of choosing a cyan ball from the box on the first draw.
p_1 <- cyan / (cyan + magenta + yellow)

# Assign a variable 'p_2' as the probability of not choosing a cyan ball on the second draw with replacement.
p_2 <- 1- p_1

# Calculate the probability that the first draw is cyan and the second draw is not cyan using `p_1` and `p_2`.
p_1 * p_2

```
```{r}
# Solution =====================================================================================================================
cyan <- 3
magenta <- 5
yellow <- 7

# The variable 'p_1' is the probability of choosing a cyan ball from the box on the first draw.
p_1 <- cyan / (cyan + magenta + yellow)

# Assign a variable 'p_2' as the probability of not choosing a cyan ball on the second draw with replacement.
p_2 <- 1 - (cyan) / (cyan + magenta + yellow)

# Calculate the probability that the first draw is cyan and the second draw is not cyan using `p_1` and `p_2`.
p_1 * p_2
```



## End of Assessment: Introduction to Discrete Probability

This is the end of the programming assignment for this section. Please DO NOT click through to additional assessments from this page. Please DO answer the question on this page. If you do click through, your scores may NOT be recorded.

Click on "Awesome" to get the "points" for this question and then return to the course on edX.

You can close this window and return to Data Science: Probability.
Answer the question
50XP
Possible Answers

    Awesome
    press
    1
    Nope
    press
    2









## Course  /  Section 1: Discrete Probability  /  1.2 Combinations and Permutations


# Combinations and Permutations


In our very first example, we imagine an urn with 5 beads--3 blue, 2 red.  To review, to compute the probability distribution of 1 draw, we simply listed out all the possibilities-- there were 5--and then for each event, we counted how many of these possibilities were associated with that event.  So for example, for the blue beads the probability is 0.6.  **For more complicated examples, however, these computations are not necessarily straightforward**.  [][*For example, what does the probability that if I draw 5 cards without replacement, I get all cards of the same suit, what is called a flush in poker?*]  

Discrete probability teaches us how to make these computations using mathematics.  Here we focus on how to use R code.  So we're going to use card games as examples.  So let's start by constructing a deck of cards using R.  For this, we will use the function [][expand.grid()] and the function [][Paste()].  We *use Paste to create strings by joining smaller strings*.  For example, if we have the number and the suit for a card, in 2 different variables we can create the card name using Paste like this.  It also works on pairs of vectors.  It performs the operation element-wise.  So if we type this line of code, we get the following result.  *The function expand.grid gives us all the combinations of 2 lists* ([][*the outcome of expand.grid function is a data.frame, be careful with this*]).  So for example, if you have blue and black pants and white, gray, and plaid shirt, all your combinations can be computed using the expand.grid function like this.  You can see all 6 combinations.  

So here's how we generate a deck of cards.  We define the four suits, we define the 13 numbers, and then we create the deck using expand.grid and then pasting together the 2 columns that expand.grid creates.  Now that we have a deck constructed, we can now start answering questions about probability.  Let's start by doing something simple.  *Let's double-check that the probability of a king in the first card is 1 in 13 with R code*.  We simply [][*compute the proportion of possible outcomes that satisfy our condition*].  So we create a vector that contains the four ways we can get a king.  That's going to be the kings variable.  And then we simply check what proportion of the deck is one of these cards and we get the answer that we expect--0.076 dot dot dot, which is 1 in 13.  

Now, ******how about the conditional probability of the second card being a king, given that the first was a king?******  Earlier we deduced that if 1 king is already out, then there's 51 left.  So the probability is 3 in 51.  But let's confirm by listing out all possible outcomes.  To do this, we're going to use [][the combinations() and permutations() functions that are available from the gtools package].  The permutations function computes for any list of size n all the different ways we can select R items.  So here's an example--here all the ways we can choose 2 numbers from the list 1, 2, 3, 4, 5.  *Notice that the order matters with the permutations() function*.  So 3, 1 is different than 1, 3, So it appears in our permutations.  Also notice that 1, 1; 2, 2; and 3, 3 don't appear, because once we pick a number, it can't appear again (no replacement).  Optionally for this function permutations, we can add a vector.  So for example, if you want to see 5 random 7-digit phone numbers out of all possible phone numbers, you could type code like this.  Here we're defining a vector of digits that goes from 0 to 9 rather than 1 through 10.  So these four lines of code generate all phone numbers, picks 5 at random, and then shows them to you.  

***To compute all possible ways that we can choose 2 cards when the order matters***, we simply type the following piece of code.  [][**Here we use permutations() function.  There's 52 cards, we're going to choose 2, and we're going to select them out of the vector that includes our card names, which we called deck earlier**].  This is going to be a matrix with 2 dimensions, 2 columns, and in this case, it's going to have 2,652 rows (*possibilities*).  Those are all the permutations.  Now, we're going to define the first card and the second card by grabbing the first and second columns using this simple piece of code.  And now we can, *for example, check how many cases have a first card that is a king--that's 204*.  [][***And now to find the conditional probability, we ask what fraction of these 204 have also a king in the second card***].  So this case we type the following piece of code.  We add all the cases that have king in the first, king in the second,  and divide by the cases that have a king in the first.  
# ======================================== Read it, Read it, Read it ================================================================================

And now we get the answer 0.058 dot dot dot, which is exactly 3 out of 51, which we had already deduced.  Note that the code we just saw is equivalent to this piece of code where we compute the proportions instead of the totals.  And this also gives us the answer that we want, 3 out of 51.  This is an R version of the multiplication rule, which tells us the probability of B, given A, is equal to proportion of A and B, or the probability of A and B, divided by the proportion of A or the probability of A.  [][*Now, what if the order does not matter?*]  For example, in blackjack, if you get an ace and a face card or a 10, it's called a natural 21, and you win automatically.  If we want to compute the probability of this happening, we want to enumerate the combinations, not permutations,  since the order doesn't matter.  So if we get an A and a king, king and an A, it's still a 21.  We don't want to count that twice.  So **notice the difference between the permutations functions**, which lists all permutations, and the combination function, where order does not matter.  

This means that 2, 1 doesn't appear because 1, 2 already appeared.  Similarly, 3, 1 and 3, 2 don't appear.  So to compute the probability of a natural 21 in blackjack, we can do this.  We can define a vector that includes all the aces, a vector that includes all the face cards, then we generate all the combinations of picking 2 cards out of 52, and then we simply count.  [][*How often do we get aces and a face card?*]  And we get the answer 0.048 dot, dot, dot.  Now, notice that in the previous piece of code we assumed that the aces come first.  This is only because we know the way that combination generates and enumerates possibilities.  But if we want to be safe, we can instead type this code, which considers both possibilities.  We get the same answer, and again, this is because we know how combinations works and how it lists the possibilities.  

Instead of using combinations to deduce the exact probability of a natural 21, **we can also use a Monte Carlo to estimate this probability**.  In this case, we draw two cards over and over and keep track of how many 21's we get.  We can use the function sample to draw a card without a replacement like this.  Here's 1 hand.  We didn't get a 21 there.  And then check if 1 card is an ace and the other is a face card or a 10.  Now we simply repeat this over and over and we get a very good approximation--in this case, 0.0488.



[][Textbook link]

Here is a link to the textbook section on combinations and permutations External link.
https://rafalab.github.io/dsbook/probability.html#combinations-and-permutations


[][Key points]

    paste() joins two strings and inserts a space in between.
    expand.grid() gives the combinations of 2 vectors or lists.
    permutations(n,r) from the gtools package lists the different ways that r items can be selected from a set of n options when order matters.
    combinations(n,r) from the gtools package lists the different ways that r items can be selected from a set of n options when order does not matter.

Code: Introducing paste() and expand.grid()

# joining strings with paste
number <- "Three"
suit <- "Hearts"
paste(number, suit)

# joining vectors element-wise with paste
paste(letters[1:5], as.character(1:5))

# generating combinations of 2 vectors with expand.grid
expand.grid(pants = c("blue", "black"), shirt = c("white", "grey", "plaid"))

Code: Generating a deck of cards

suits <- c("Diamonds", "Clubs", "Hearts", "Spades")
numbers <- c("Ace", "Deuce", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King")
deck <- expand.grid(number = numbers, suit = suits)
deck <- paste(deck$number, deck$suit)

# probability of drawing a king
kings <- paste("King", suits)
mean(deck %in% kings)

Code: Permutations and combinations

Correction: The code shown does not generate all 7 digit phone numbers because phone numbers can have repeated digits. It generates all possible 7 digit numbers without repeats.

library(gtools)
permutations(5,2)    # ways to choose 2 numbers in order from 1:5
all_phone_numbers <- permutations(10, 7, v = 0:9)
n <- nrow(all_phone_numbers)
index <- sample(n, 5)
all_phone_numbers[index,]

permutations(3,2)    # order matters
combinations(3,2)    # order does not matter

Code: Probability of drawing a second king given that one king is drawn

hands <- permutations(52,2, v = deck)
first_card <- hands[,1]
second_card <- hands[,2]
sum(first_card %in% kings)

sum(first_card %in% kings & second_card %in% kings) / sum(first_card %in% kings)

Code: Probability of a natural 21 in blackjack

aces <- paste("Ace", suits)
facecard <- c("King", "Queen", "Jack", "Ten")
facecard <- expand.grid(number = facecard, suit = suits)
facecard <- paste(facecard$number, facecard$suit)

hands <- combinations(52, 2, v=deck) # all possible hands

# probability of a natural 21 given that the ace is listed first in `combinations`
mean(hands[,1] %in% aces & hands[,2] %in% facecard)

# probability of a natural 21 checking for both ace first and ace second
mean((hands[,1] %in% aces & hands[,2] %in% facecard)|(hands[,2] %in% aces & hands[,1] %in% facecard))

Code: Monte Carlo simulation of natural 21 in blackjack

Note that your exact values will differ because the process is random and the seed is not set.

# code for one hand of blackjack
hand <- sample(deck, 2)
hand

# code for B=10,000 hands of blackjack
B <- 10000
results <- replicate(B, {
    hand <- sample(deck, 2)
    (hand[1] %in% aces & hand[2] %in% facecard) | (hand[2] %in% aces & hand[1] %in% facecard)
})
mean(results)




```{r}
number <- "Three"
suit <- "Hearts"

paste(number, suit)



paste(letters[1:5], as.character(1:5))
```

```{r}
expand.grid(pants = c("blue", "black"), shirt = c("white", "gray", "plaid"))
```

# This is cool, we can image what we want and applying our thought into code, R or Python, no difference
# ===================================================================================================================================
```{r}
suits <- c("Diamonds", "Clubs", "Hearts", "Spades")
numbers <- c("Ace", "Deuce", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King")


deck <- expand.grid(suit = suits, number = numbers)
length(deck[, 1])
head(deck)

deck <- paste(deck$suit, deck$number)
length(deck)


deck
```

```{r}
kings <- paste(suits, "King")

kings


mean(deck %in% kings)

#mean(length(kings)/length(deck))


# this is how I think calculating probability of second card being king given that the first card is already a king
# ============================================================================================================================
mean((length(kings)-1)/(length(deck)-1))
```

```{r}
library(gtools)


head(permutations(5, 2))
length(permutations(52, 2)[, 1])    # Dont forget after permutation or combinations, you'll have two dimensional df =================================
length(combinations(52, 2)[, 1])

data.frame(permutations(52, 2, v = deck))


all_phone_numbers <- permutations(10, 7, v=0:9)
n <- nrow(all_phone_numbers)

index <- sample(n, 5)

all_phone_numbers[index,]
```

```{r}
library(gtools)

suits <- c("Diamonds", "Clubs", "Hearts", "Spades")
numbers <- c("Ace", "Deuce", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King")


deck <- expand.grid(suit = suits, number = numbers)
deck <- paste(deck$suit, deck$number)
deck


hands <- permutations(52, 2, v = deck)     # ===========================================================================

length(hands[, 1])



n = nrow(hands)

index <- sample(n, 6)      # ===========================================================================================

hands[index, ]



first_card <- hands[, 1]
second_card <- hands[, 2]

head(second_card)

length(unique(first_card))



# first_card %in% kings      # Thank God I tried this code, and find the causation of wrong code
sum(first_card %in% kings)


sum(first_card %in% kings & second_card %in% kings)/sum(first_card %in% kings)
```

# =============================================================================================================================================
![how to think this equation in the right way](C:/Users/JJ/Pictures/Screenshot_20220612-121142_Gallery.jpg)

![Yes, this image has to be here](C:/Users/JJ/Pictures/20220608_225119.jpg)

```{r}
combinations(3, 2)

permutations(3, 2)
```

```{r}
suits


aces <- paste("Ace", suits)
aces

facedcard <- c("Ten", "Jack", "Queen", "King")
facedcard_combine <- expand.grid(faces = facedcard, suit = suits)

facedcard_combine <- paste(facedcard_combine$faces, facedcard_combine$suit)


facedcard_combine



suits <- c("Diamonds", "Clubs", "Hearts", "Spades")
numbers <- c("Ace", "Deuce", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King")


deck <- expand.grid(suit = suits, number = numbers)
deck <- paste(deck$number, deck$suit)


all_hands <- permutations(52, 2, v = deck)      # =========================================================================================
head(all_hands)                                 # First finish this approach, and Notice in Blackjack the natural 21 means cards, not order



# I'll apply the conditional probability equations here: Pr(A and B) = Pr(A) * Pr(B|A)
natural21 <- mean(all_hands[, 1] %in% aces) * sum(all_hands[, 1] %in% aces & all_hands[, 2] %in% facedcard_combine)/sum(all_hands[, 1] %in% aces)
natural21
```

```{r}
library(gtools)


suits <- c("Clubs", "Diamonds", "Hearts", "Spades")

aces <- paste("Ace", suits)
aces


facedcard <- c("Ten", "Jack", "Queen", "King")

facedcard_combine <- expand.grid(faces = facedcard, suit = suits)

facedcard_combine <- paste(facedcard_combine$faces, facedcard_combine$suit)
facedcard_combine



suits <- c("Diamonds", "Clubs", "Hearts", "Spades")
numbers <- c("Ace", "Deuce", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King")


deck <- expand.grid(suit = suits, number = numbers)
deck <- paste(deck$number, deck$suit)




hands <- combinations(52, 2, v = deck)
length(hands[, 2])


mean(hands[, 1] %in% aces & hands[, 2] %in% facedcard_combine)
mean(hands[, 1] %in% aces & hands[, 2] %in% facedcard_combine) + mean(hands[, 1] %in% facedcard_combine & hands[, 2] %in% aces)
# ===============================================================================================================================
# Here we should notice how the combination function works

mean((hands[, 1] %in% aces & hands[, 2] %in% facedcard_combine) | (hands[, 1] %in% facedcard_combine & hands[, 2] %in% aces))
```

```{r}
hands <- sample(deck, 2)

hands




B <- 100000
result <- replicate(B, {
  hand <- sample(deck, 2)
  (hand[1] %in% aces & hand[2] %in% facedcard_combine) | 
    hand[2] %in% aces & hand[1] %in% facedcard_combine})

mean(result)
```






![](C:/Users/JJ/Pictures/our very first example is 5 beads in a urn.png)

![](C:/Users/JJ/Pictures/here is the probability of randomly picking a blue beads from the urn.png)

![](C:/Users/JJ/Pictures/r function expand.grid.png)

![](C:/Users/JJ/Pictures/r function paste.png)

![](C:/Users/JJ/Pictures/we use paste function to create strings be joining smaller strings.png)

![](C:/Users/JJ/Pictures/the paste function performs the operation elements wise.png)

![](C:/Users/JJ/Pictures/expand.grid gives us all the combination of two lists.png)

![](C:/Users/JJ/Pictures/using what we just leant r functions, expand.grid and paste to generate a deck of cards.png)

![now, how about the second card being a king, given that the first card is king ??? Think about it](C:/Users/JJ/Pictures/this is the first king probability.png)

![Note: these functions are available in gtools package](C:/Users/JJ/Pictures/we are going to use the combinations function and permutations function.png)

![](C:/Users/JJ/Pictures/what does a permutations function does.png)

![Notice: here the order maters, and once we pick a number, it cant appear again](C:/Users/JJ/Pictures/here we list all the way we can choose 2 numbers from the list 1 2 3 4 5.png)

![](C:/Users/JJ/Pictures/we can add vector for this permutations function.png)

![](C:/Users/JJ/Pictures/a sample permutations.png)

![](C:/Users/JJ/Pictures/and we will define grabbing first card and the second card using this code.png)

![](C:/Users/JJ/Pictures/check how many cases have first card as king, but I failed running this code.png)

![](C:/Users/JJ/Pictures/notice how we calculate the conditional probability.png)

![](C:/Users/JJ/Pictures/using proportions will also gives us the answers.png)

![](C:/Users/JJ/Pictures/multiplication rule equation.png)

![](C:/Users/JJ/Pictures/combinations.png)

![](C:/Users/JJ/Pictures/here is the permutations function.png)

![](C:/Users/JJ/Pictures/and here is the outcome from a combination function.png)

![](C:/Users/JJ/Pictures/compute the natural 21 in blackjack.png)

![But be careful how combination function wroks, as this code seems counterintuitive](C:/Users/JJ/Pictures/using thie piece of code to compute the probability of natural 21, where aces or faced card order doesn't matter.png)

![](C:/Users/JJ/Pictures/we get the same answer, and this is because combinations function works and how it list the probabilities.png)

![](C:/Users/JJ/Pictures/use the sample function to simulation draw a card without replacement with default replace vector.png)

![](C:/Users/JJ/Pictures/here we sue monte carlo simulation with this code to draw two card from the deck without replacement.png)

![](C:/Users/JJ/Pictures/and we can repeat this over and over and then we get a very good approximation of probability.png)









# The Birthday Problem


Suppose you're in a classroom with 50 people.  If we assume this is a randomly selected group, what is the chance that at least two people have the same birthday?  Although it is somewhat advanced, we can actually deduce this mathematically, and we do this later, but now, we're going to use Monte Carlo simulations.  For simplicity, we assumed that nobody was born on February 29th.  This actually doesn't change the answer much.  

All right, first, note that birthdays can be represented as numbers between 1 and 365.  So a sample of 50 random birthdays can be obtained simply using the sample function, like this.  To check if, in this particular set of 50 people we have at least two with the same birthday, we can use the function duplicated, which returns true whenever an element of a vector has already appeared in that vector.  So here's an example.  If I type duplicated 1, 2, 3, 1, 4, 3, 5, , we get true's for the 1 and the 3 the second time they appear.  So to check if two birthdays were the same, we simply use any and duplicated functions, like this.  And in the case that we just generated, we actually do have this happening.  We did have two people, at least two people, with the same birthday.  We get true.  Now, to estimate the probability, we're going to repeat this experiment.  We're going to run a Monte Carlo simulation over and over again.  

So what we do is we do it 10,000 times.  We use the replicate function like this.  And when we're done, we get that the probability of having two people, at least two people, with the same birthday in a group of 50 people is about 98%.  Were you expecting this to be so high?  People tend to underestimate these probabilities, so [][*it might be an opportunity for you to bet and make some money off of your friends*] (key point of this course, please keep in mind).  To get an intuition as to why this is so high, think of what happens as you get close to 365 people.  At this stage, we run out of days, and the probability is 1.  In the next video, we're going to actually compute this probability for different group sizes and see how fast it gets close to 1.  


[][Textbook link]

Here is a link to the textbook section on the birthday problem External link.
https://rafalab.github.io/dsbook/probability.html#birthday-problem


[][Key points]

    duplicated() takes a vector and returns a vector of the same length with TRUE for any elements that have appeared previously in that vector.
    We can compute the probability of shared birthdays in a group of people by modeling birthdays as random draws from the numbers 1 through 365. We can then use this sampling model of birthdays to run a Monte Carlo simulation to estimate the probability of shared birthdays.

Code: The birthday problem

# checking for duplicated bdays in one 50 person group
n <- 50
bdays <- sample(1:365, n, replace = TRUE)    # generate n random birthdays
any(duplicated(bdays))    # check if any birthdays are duplicated

# Monte Carlo simulation with B=10000 replicates
B <- 10000
results <- replicate(B, {    # returns vector of B logical values
    bdays <- sample(1:365, n, replace = TRUE)
    any(duplicated(bdays))
})
mean(results)    # calculates proportion of groups with duplicated bdays




```{r}
birthdays <- sample(1:365, 50, replace = T)

length(unique(birthdays))      # So we do have the same birthday classmates in a 50 sized class, should repeat it many times and simulate the %


mean(birthdays %in% unique(birthdays))
```

```{r}
birthdaycheck <- replicate(100000, {
  same <- sample(365, 50, replace = T)
  50 - length(unique(same)) >=1             # I haven't learn the course, did I doing it wrong or something?  Why its so high ???
})


mean(birthdaycheck)
```




![](C:/Users/JJ/Pictures/in a random selected class of 50 people, the chance of at least two people share birthday.png)

![](C:/Users/JJ/Pictures/using r to generate randomly selected 50 birthdays.png)

![](C:/Users/JJ/Pictures/duplicated function.png)

![](C:/Users/JJ/Pictures/a example of duplicated function.png)

![](C:/Users/JJ/Pictures/we can use any function combined with duplicated function to check if duplicate happened in list.png)

![](C:/Users/JJ/Pictures/the probability of at least two classmates sharing same birthday in 50 people sized class is freaking high.png)









# sapply


Say you want to use what you've just learned about the birthday problem to bet with friends about two people having the same birthday in a group of people.  [][*When are the chances larger than 50%?  Larger than 75%? *]  Let's create a lookup table.  We can quickly create a function to compute this for any group.  We write the function like this.  We'll call it compute prob, and we'll basically make the calculations for the probability of two people having the same birthday.  We will use a small Monte Carlo simulation to do it.  Now that we've done this, we want to compute this function, we want to apply this function to several values of n, let's say from 1 to 60.  

Let's define n as a sequence starting at 1 and ending at 60.  Now, we can use a for loop to apply this function to each value in n, but it turns out that *for loops are rarely the preferred approach in R*.  In general, we try to perform operations on entire vectors.  Arithmetic operations, for example, operate on vectors in an element wise fashion.  We saw this when we learned about R.  So if we type x equals 1 through 10, now X is the vector starting at 1 and ending at 10, and we compute the square root of x, it actually computes the square root for each element.  

Equally, if we define y to be 1 through 10, and then multiply x by y, it multiplies each element 1 by 1--1 times 1, 2 times 2, et cetera.  So there's really no need for for loops.  [][*But not all functions work this way*].  You can't just send a vector to any function in R.  For example, the function we just wrote does not work element-wise since it's expecting a scalar, it's expecting an n.  This piece of code does not do what we want.  If we type compute prob and send it the vector n, we will not get what we want.  We will get just one number.  What we can do instead is use the function sapply().  **sapply permits us to perform element-wise operations on any function**.  Here's how it works.  We'll define a simple example for the vector 1 through 10.  If we want to apply the square roots of each element of x, we can simply type sapply x comma square root, and it'll apply square root to each element of x.  Of course, we don't need to do this because square root already does that, but we are using it as a simple example.  So for our case, we can simply type prob equals sapply n-- n is our vector--and then the function we define compute prob.  

And this will assign to each element of prob the probability of two people having the same birthday for that n.  And now we can very quickly make a plot.  We plot the probability of two people having the same birthday against the size of the group.  Now, let's compute the exact probabilities rather than use Monte Carlo simulations.  The function we just defined uses a Monte Carlo simulation, but we can use what we've learned about probability theory to compute the exact value.  Not only do we get the exact answer using math, but the computations are much faster since we don't have to generate experiments.  We simply get a number.  To make the math simpler for this particular problem, [][*instead of computing the probability of it happening, we'll compute the probability of it not happening, and then we can use the multiplication rule*].  

*==============You need to break your thought to tensor level, and pushing it forward one by one, then you'll have the solution ==============*
Let's start with the first person.  The probability that person 1 has a unique birthday is 1, of course.  All right.  Now let's move on to the second one.  The probability that the second person has a unique birthday given that person 1 already took one of the days is 364 divided by 365.  *Then for a person 3, given that the first two people already have unique birthdays, that leaves 363.  So now that probability is 363 divided by 365*.  If we continue this way and find the chances of all, say, 50 people having unique birthdays, we would multiply 1 times 364 divided by 365, times 363 divided by 365, dot dot dot, all the way to the 50th element.  

Here's the equation.  Now, we can easily write a function that does this.  This time we'll call it exact prob.  It takes n as a argument, and it computes this probability using this simple code.  Now we can compute each probability for each n using sapply again, like this.  And if we plot it, we can see that the Monte Carlo simulations were almost exactly right.  They were almost exact approximations of the actual value.  Now, notice had it not been possible to compute the exact probabilities, something that sometimes happens, we would have still been able to accurately estimate the probabilities using Monte Carlo.  



[][Textbook links]
The textbook discussion of the basics of sapply() can be found in this textbook section External link.
https://rafalab.github.io/dsbook/programming-basics.html#vectorization
The textbook discussion of sapply() for the birthday problem can be found within the birthday problem section External link.
https://rafalab.github.io/dsbook/probability.html#birthday-problem



[][Key points]

    Some functions automatically apply element-wise to vectors, such as sqrt() and *.
    However, other functions do not operate element-wise by default. This includes functions we define ourselves.

    The function sapply(x, f) allows any other function f to be applied element-wise to the vector x.

    The probability of an event happening is 1 minus the probability of that event not happening:
        Pr(event) = 1 - Pr(no event)
        
    We can compute the probability of shared birthdays mathematically:
        Pr(shared birthdays) = 1 - Pr(no shared birthdays) = 1 - (1 * 364/365 * 363/365 * ... * (365-n+1)/365)

 

Code: Function for birthday problem Monte Carlo simulations

Note that the function body of compute_prob() is the code that we wrote in the previous video. If we write this code as a function, we can use sapply() to apply this function to several values of n.

# function to calculate probability of shared bdays across n people
compute_prob <- function(n, B = 10000) {
	same_day <- replicate(B, {
    	bdays <- sample(1:365, n, replace = TRUE)
        any(duplicated(bdays))
    })
    mean(same_day)
}

n <- seq(1, 60)

Code: Element-wise operation over vectors and sapply

x <- 1:10
sqrt(x)    # sqrt operates on each element of the vector

y <- 1:10
x*y    # * operates element-wise on both vectors

compute_prob(n)    # does not iterate over the vector n without sapply

x <- 1:10
sapply(x, sqrt)    # this is equivalent to sqrt(x)

prob <- sapply(n, compute_prob)    # element-wise application of compute_prob to n
plot(n, prob)

Code: Computing birthday problem probabilities with sapply

# function for computing exact probability of shared birthdays for any n
exact_prob <- function(n){
    prob_unique <- seq(365, 365-n+1)/365   # vector of fractions for mult. rule
    1 - prod(prob_unique)    # calculate prob of no shared birthdays and subtract from 1
}

# applying function element-wise to vector of n values
eprob <- sapply(n, exact_prob)

# plotting Monte Carlo results and exact probabilities on same graph
plot(n, prob)    # plot Monte Carlo results
lines(n, eprob, col = "red")    # add line for exact prob




```{r}
library(tidyverse)


compute_prob <- function(n, B = 100000){
  same_day <- replicate(B, {                # We are applying a Monte Carlo simulation, obviously we need replicate function
    bdays <- sample(1:365, n, replace = T)
    any(duplicated(bdays))
  })
  mean(same_day)
}



compute_prob(23)       # Can you believe it, I got one shoot and get the correct answer 50%
                       # The power of replacement, how interesting ???
# ===============================================================================================================================
# Get prepared, womeday we may need to write a R function for later use



# ===============================================================================================================================
n <- seq(1, 30)

sapply(n, compute_prob)   # =========================================================================================================



plot(sapply(n, compute_prob))
```

```{r}
exact_prob <- function(n){                # =============================================================================================
  prob_unique <- seq(365, 365-n+1)/365    # What does this line of code doing ???
  1 - prod(prob_unique)       # prod stands for product calculation
}


exact_prob(23)



eprob <- sapply(60, exact_prob)           # Using sappy() a sequence with defined function, but inside the function, seq() already did element wise 
                                          # ========================================================================================================
eprob
```

```{r}
ff <- seq(365, 300)


ff
```

```{r}
n <- seq(1: 60)      # ==================================================================================================================



prob <- sapply(n, compute_prob)       ##############


exact_prob <- function(n){                # =============================================================================================
  prob_unique <- seq(365, 365-n+1)/365    # What does this line of code doing ???
  1 - prod(prob_unique)       # prod stands for product calculation
}



eprob <- sapply(n, exact_prob)         ##############


plot(n, prob) 
lines(n, eprob, col = "red")
```

![](C:/Users/JJ/Pictures/the monte carlo simulation and the calculation outcome were almost identical.png)









![](C:/Users/JJ/Pictures/say we are digging on the same birthday peobability problem, when would the probability of at least 2 people share birthday larger than 50%.png)

![](C:/Users/JJ/Pictures/and how about larger than larger than 75%.png)

![This image ment to be here](C:/Users/JJ/Pictures/20220609_233459.jpg)

![](C:/Users/JJ/Pictures/can you see it, how can we change the variable n to change random pick group size and check if ther is same birthday shared within.png)

![](C:/Users/JJ/Pictures/r provides the calculation element wise, and for loop in r pperforms bad.png)

![On any function](C:/Users/JJ/Pictures/r sapply function permits us to perform element-wise operations.png)

![](C:/Users/JJ/Pictures/and we can make a plot with plot function on at least 2 people share birthday from 1 through 30 people sized group.png)

![](C:/Users/JJ/Pictures/lets start with the first person has a unique birthday.png)

![break thought into tensors and approaching the solution.png](C:/Users/JJ/Pictures/break thought into tensors and approaching the solution.png)

![Now you must can understand this, this is the bridge](C:/Users/JJ/Pictures/and here is for the person 3 have unique birthday given person 1 and person 2 already has unique birthday .png)

![](C:/Users/JJ/Pictures/not saying we are finding the group size n which no one share birthday in that group, here is the probability.png)

![](C:/Users/JJ/Pictures/after observed the pattern in above sample, we can writ that down into a function, and let r help us doing the calculations.png)

![](C:/Users/JJ/Pictures/using sapply function to applying sequence element wise function calculation.png)









# How Many Monte Carlo Experiments are Enough?


In the examples we have seen, we have used 10,000 Monte Carlo experiments.  It turns out that this provided very accurate estimates for the examples
we looked at.  In more complex calculations, 10,000 may not nearly be enough.  Also for some calculations, 10,000 experiments might not be computationally feasible, and it might be more than we need.  In practice, we won't know what the answer is, so we don't know if our Monte Carlo estimate is accurate.  

We know that the larger the number of experiments, we've been using the letter B to represent that, the better the approximation.  But how big do we need it to be?  This is actually a challenging question, and answering it often requires advanced theoretical statistics training.  One practical approach we will describe here is to check for the stability of the estimate.  Here's an example with the birthday problem.  We're going to use n equals 22.  There's 22 people.  So we're going to run a simulation where we compute or estimate the probability of two people having a certain birthday using different sizes of the Monte Carlo simulations.  So the value of b going to go from 10, to 20, to 40, to 100, et cetera.  We compute the simulation, and now we look at the values that we get for each simulation.  

Remember, each simulation has a different b, a different number of experiments.  When we see this graph, we can see that it's wiggling up and down.  That's because the estimate is not stable yet.  It's not such a great estimate.  But as b gets bigger and bigger, eventually it starts to stabilize.
And that's when we start getting a feeling for the fact that now perhaps we have a large enough number of experiments.  


[][Textbook link]

Here is a link to the matching textbook section External link.
https://rafalab.github.io/dsbook/probability.html#infinity-in-practice


[][Key points]

    The larger the number of Monte Carlo replicates , the more accurate the estimate.
    Determining the appropriate size for can require advanced statistics.
    One practical approach is to try many sizes for and look for sizes that provide stable estimates.

Code: Estimating a practical value of B

This code runs Monte Carlo simulations to estimate the probability of shared birthdays using several B values and plots the results. When B is large enough that the estimated probability stays stable, then we have selected a useful value of B.

B <- 10^seq(1, 5, len = 100)    # defines vector of many B values
compute_prob <- function(B, n = 22){    # function to run Monte Carlo simulation with each B
	same_day <- replicate(B, {
    	bdays <- sample(1:365, n, replace = TRUE)
        any(duplicated(bdays))
    })
    mean(same_day)
}

prob <- sapply(B, compute_prob)    # apply compute_prob to many values of B
plot(log10(B), prob, type = "l")    # plot a line graph of estimates 




```{r}
B <- 10^seq(1, 5, len=100)

compute_prob22 <- function(B, n=22){
  same_day <- replicate(B, {
    bdays <- sample(365, n, replace = T)
    any(duplicated(bdays))
  })
  mean(same_day)
}


prob22 <- sapply(B, compute_prob22)
prob22

hist(prob22)
```

```{r}
plot(log10(B), prob22)
```





![This is actually a challenging question, and answering it often requires advanced theoretical statistics training.](C:/Users/JJ/Pictures/how big does b need to be, depending on the problem we are solving.png)

![](C:/Users/JJ/Pictures/apply different sized monte carlo simulation on shared birthday with 22 people.png)

![](C:/Users/JJ/Pictures/and this is how we plot the outcome of same birthday monte carlo simulation.png)

![](C:/Users/JJ/Pictures/and using this graph to represent the trending of probability whne change the size of simulation.png)









# DataCamp Assessment: Combinations and Permutations



Assessment due Jun 15, 2022 10:43 AWST

This assessment covers combinations and permutations.

By clicking OK, you agree to DataCamp's privacy policy: https://www.datacamp.com/privacy-policy. Note that you might need to disable your pop-up blocker, or allow "www.datacamp.com" in your pop-up blocker allowed list. When you have completed the exercises, return to edX to continue your learning.
Assessment: Combinations and permutations (External resource) (5.0 points possible)
By clicking OK, you agree to DataCamp's privacy policy: https://www.datacamp.com/privacy-policy.


## Exercise 1. Independence

Imagine you draw two balls from a box containing colored balls. You either replace the first ball before you draw the second or you leave the first ball out of the box when you draw the second ball.

Under which situation are the two draws independent of one another?

Remember that two events A and B are independent if Pr(A and B) = Pr(A) * P(B).
Instructions
50 XP
Possible Answers

    You don't replace the first ball before drawing the next.
    You do replace the first ball before drawing the next.
    Neither situation describes independent events.
    Both situations describe independent events.


## Exercise 2. Sampling with replacement

Say you’ve drawn 5 balls from the a box that has 3 cyan balls, 5 magenta balls, and 7 yellow balls, with replacement, and all have been yellow.

What is the probability that the next one is yellow?
Instructions
100 XP

    Assign the variable p_yellow as the probability of choosing a yellow ball on the first draw.
    Using the variable p_yellow, calculate the probability of choosing a yellow ball on the sixth draw.


# Below are my solutions
```{r}
cyan <- 3
magenta <- 5
yellow <- 7

# Assign the variable 'p_yellow' as the probability that a yellow ball is drawn from the box.
p_yellow <- yellow/(cyan + magenta + yellow)
p_yellow

# Using the variable 'p_yellow', calculate the probability of drawing a yellow ball on the sixth draw. Print this value to the console.
p_yellow6 <- (1 - p_yellow)^5 * p_yellow        # Those are my imagination, figured what does the question ask for first
p_yellow6
```

# Incorrect submission
You are not providing a calculation that gives the correct answer. The probability of choosing a yellow ball does not depend on subsequent draws when balls are replaced after each draw. 


## Exercise 3. Rolling a die

If you roll a 6-sided die once, what is the probability of not seeing a 6? If you roll a 6-sided die six times, what is the probability of not seeing a 6 on any of those rolls?
Instructions
100 XP

    Assign the variable p_no6 as the probability of not seeing a 6 on a single roll.
    Then, calculate the probability of not seeing a 6 on six rolls using p_no6.

```{r}
# Assign the variable 'p_no6' as the probability of not seeing a 6 on a single roll.
p_no6 <- 1/6

# Calculate the probability of not seeing a 6 on six rolls using `p_no6`. Print your result to the console: do not assign it to a variable.
1- p_no6
```

# Incorrect submission
Make sure that you use p_no6 as your variable name for the probability of rolling any number other than six on a 6-sided die. 

# Incorrect submission
You are not providing a calculation that gives the correct answer. The probability of rolling any number other than a six does not change from roll to roll. 

```{r}
# Assign the variable 'p_no6' as the probability of not seeing a 6 on a single roll.
p_no6 <- 5/6

# Calculate the probability of not seeing a 6 on six rolls using `p_no6`. Print your result to the console: do not assign it to a variable.
1 - p_no6
```

```{r}
# Assign the variable 'p_no6' as the probability of not seeing a 6 on a single roll.
p_no6 <- 5/6

# Calculate the probability of not seeing a 6 on six rolls using `p_no6`. Print your result to the console: do not assign it to a variable.
p_no6
```

```{r}
# Assign the variable 'p_no6' as the probability of not seeing a 6 on a single roll.
p_no6 <- 5/6

# Calculate the probability of not seeing a 6 on six rolls using `p_no6`. Print your result to the console: do not assign it to a variable.
p_no6^6
```

# Its a problem with carefully read the silly question instead of training your statistics knowledge and etc


## Exercise 4. Probability the Celtics win a game

Two teams, say the Celtics and the Cavs, are playing a seven game series. The Cavs are a better team and have a 60% chance of winning each game.

What is the probability that the Celtics win at least one game? Remember that the Celtics must win one of the first four games, or the series will be over!
Instructions
100 XP

    Calculate the probability that the Cavs will win the first four games of the series.
    Calculate the probability that the Celtics win at least one game in the first four games of the series.

```{r}
# Assign the variable `p_cavs_win4` as the probability that the Cavs will win the first four games of the series.
p_cavs_win4 <- (0.6)^4

# Using the variable `p_cavs_win4`, calculate the probability that the Celtics win at least one game in the first four games of the series.
1 - p_cavs_win4
```


## Exercise 5. Monte Carlo simulation for Celtics winning a game

Create a Monte Carlo simulation to confirm your answer to the previous problem by estimating how frequently the Celtics win at least 1 of 4 games. Use B <- 10000 simulations.

The provided sample code simulates a single series of four random games, simulated_games.
Instructions
100 XP

    Use the replicate function for B <- 10000 simulations of a four game series. The results of replicate should be stored to a variable named celtic_wins.
    Within each simulation, replicate the sample code to simulate a four-game series named simulated_games. Then, use the any function to indicate whether the four-game series contains at least one win for the Celtics. Perform these operations in two separate steps.
    Use the mean function on celtic_wins to find the proportion of simulations that contain at least one win for the Celtics out of four games.

# This is wrong code
```{r}
# This line of example code simulates four independent random games where the Celtics either lose or win. Copy this example code to use within the `replicate` function.
simulated_games <- sample(c("lose","win"), 4, replace = TRUE, prob = c(0.6, 0.4))

# The variable 'B' specifies the number of times we want the simulation to run. Let's run the Monte Carlo simulation 10,000 times.
B <- 10000

# Use the `set.seed` function to make sure your answer matches the expected result after random sampling.
set.seed(1)

# Create an object called `celtic_wins` that replicates two steps for B iterations: (1) generating a random four-game series `simulated_games` using the example code, then (2) determining whether the simulated series contains at least one win for the Celtics.

celtic_wins <- replicate(B, {
    simulated_games <- sample(c("lose","win"), 4, replace = TRUE, prob = c(0.6, 0.4))
    any(duplicated(simulated_games))
})



# Calculate the frequency out of B iterations that the Celtics won at least one game. Print your answer to the console.
mean(celtic_wins)
```

# This should be the correct one
```{r}
# This line of example code simulates four independent random games where the Celtics either lose or win. Copy this example code to use within the `replicate` function.
simulated_games <- sample(c("lose","win"), 4, replace = TRUE, prob = c(0.6, 0.4))

# The variable 'B' specifies the number of times we want the simulation to run. Let's run the Monte Carlo simulation 10,000 times.
B <- 10000

# Use the `set.seed` function to make sure your answer matches the expected result after random sampling.
set.seed(1)

# Create an object called `celtic_wins` that replicates two steps for B iterations: (1) generating a random four-game series `simulated_games` using the example code, then (2) determining whether the simulated series contains at least one win for the Celtics.

celtic_wins <- replicate(B, {
    simulated_games <- sample(c("lose","win"), 4, replace = TRUE, prob = c(0.6, 0.4))
    any(simulated_games %in% "win")
})



# Calculate the frequency out of B iterations that the Celtics won at least one game. Print your answer to the console.
mean(celtic_wins)
```


## End of Assessment: Independence and Multiplication Rule

This is the end of the programming assignment for this section. Please DO NOT click through to additional assessments from this page. Please DO answer the question on this page. If you do click through, your scores may NOT be recorded.

Click on "Awesome" to get the "points" for this question and then return to the course on edX.

You can close this window and return to Data Science: Probability.
Answer the question
50XP
Possible Answers

    Awesome
    press
    1
    Nope
    press
    2








## Course  /  Section 1: Discrete Probability  /  1.3 Addition Rule and Monty Hall



# The Addition Rule


Earlier, we showed you how to compute the probability of a natural 21 in blackjack.  This is **getting a face card and an ace in your first draw**.  Here, we're going to show you the [][*addition rule*], which gives you another way to compute this probability.  The addition rule tells us that the probability of A or B, right, we're going to have to make this calculation now, because [][***you can get to 21 in two ways.  You can get either a face card and then an ace.  Or you can get an ace and then a face card***].  So we're asking what's the probability of that or?  A or B?  The addition rule tells us the probability of A or B is the probability of A plus the probability a B minus the probability of A and B.  

To understand why this makes sense, [][*think of a Venn diagram*].  If we're computing the probability of this whole thing happening, A or B, we can add the blue circle plus the pink circle, and then subtract the middle because we have added it twice by adding the blue plus the pink.  So it makes sense-- the addition rule makes a lot of sense.  So now let's apply it to the natural 21.  In the case of natural 21, the intersection is empty.  Since both hands can't happen, you can't have both an ace and then a face card, and then at the same time have a face card and then an ace.  Those two things can't happen at the same time.  So this will be a very easy application of the addition rule.  The probability of an ace followed by a face card we know is 1 over 13 times 16 divided by 51.  And the probability of a face card followed by an ace is 16 over 52 times 4 over 51.  These are actually the same, which makes sense due to symmetry.  

These two values are actually the same.  In any case, we get the same result that we got before for the natural 21, which is about 0.05.  


[][Textbook link]

Here is a link to the textbook section on the addition rule External link.
https://rafalab.github.io/dsbook/probability.html#addition-rule


[][Clarification]

By "facecard", the professor means a card with a value of 10 (K, Q, J, 10).
Key points

[][**    The addition rule states that the probability of event A or event B happening is the probability of event A plus the probability of event B minus the probability of both events A and B happening together.**]
[][**        Pr(A or B) = Pr(A) + Pr(B) - Pr(A and B)**]

[][*    Note that (A or B) is equivalent to (A | B).*]  ========================================================================================

Example: The addition rule for a natural 21 in blackjack

[][***We apply the addition rule where A = drawing an ace then a facecard and B = drawing a facecard then an ace. Note that in this case, both events A and B cannot happen at the same time, so Pr(A and B) = 0***]

        Pr(aces then faced cards) = 4/52 * 16/51                 ------------> Pr(B|A)
        pr(faced cards then aces) = 16/52 * 4/51                 ------------> Pr(A|B)
        Pr(aces then faced cards | faced cards then aces) = 4/51 * 16/51 * 16/52 * 4/51 = 0.0483.

**
 


![this gives you another to compute the natural 21 in blackjack card game](C:/Users/JJ/Pictures/the addition rule.png)

![](C:/Users/JJ/Pictures/this is what addition rule tell us.png)

![if we compute this whole thing happening, a or b](C:/Users/JJ/Pictures/we can use a ven diagram to understand this.png)

![](C:/Users/JJ/Pictures/the probability of an ace followed by a faced card is this.png)

![](C:/Users/JJ/Pictures/and this the the probability of a faced card followed by an ace card.png)

```{r}
1/13 * 16/51

16/52 * 4/51
```







# The Monty Hall Problem






# Trying to understand the logic behind the below R code, next time you should be able to draft those kind to code by reading the questions =========
```{r}
B <- 100000

stick <- replicate(B, {
  doors <- as.character(1:3)
  prize <- sample(c("Car", "Goat", "Goat"))
  prize_door <- doors[prize == "Car"]
  the_pick <- sample(doors, 1)
  show <- sample(doors[!doors %in% c(the_pick, prize_door)], 1)
  stick <- the_pick
  stick == prize_door
})


mean(stick)




switch <- replicate(B, {
  doors <- as.character(1:3)
  prize <- sample(c("Car", "Goat", "Goat"))
  prize_door <- doors[prize == "Car"]
  the_pick <- sample(doors, 1)
  show <- sample(doors[!doors %in% c(the_pick, prize_door)], 1)
  switch <- sample(doors[!doors %in% c(the_pick, show)], 1)
  switch == prize_door
})


mean(switch)
```

```{r}
doors <- as.character(1:3)
doors

prize <- sample(c("Car", "Goat", "Goat"))
prize
```





![](C:/Users/JJ/Pictures/monty hall problem.png)

![](C:/Users/JJ/Pictures/behind one door is the prize, and had goat behind other two.png)

![and show contestant that there is no prize behind that door](C:/Users/JJ/Pictures/if the contestant failed at first try, monty hall will oepn one of two remaining door that has a goat behind it.png)

![](C:/Users/JJ/Pictures/because the original choose are based on first condition, the 3 potential prize probabilities.png)

![](C:/Users/JJ/Pictures/but if you switch, the chance will double to 2 in 3.png)

![](C:/Users/JJ/Pictures/lets find the probability of monty hall problem with monte carlo simulation and comparing with 2 strategies.png)

![](C:/Users/JJ/Pictures/lets go through the code with stick to the same door strategy with monte carlo simulation.png)





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































